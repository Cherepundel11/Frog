#include <iostream>
#include <cstdlib>

using namespace std;

// Функция для поиска строк с нулевыми элементами
int* findZeroRows(int** matrix, int rows, int cols, int* zeroRowsCount) {
    int* temp = (int*)malloc(rows * sizeof(int));  // Временный массив
    *zeroRowsCount = 0;

    if (temp == NULL) {
        return NULL;
    }

    // Поиск строк, содержащих хотя бы один нулевой элемент
    for (int i = 0; i < rows; i++) {
        bool hasZero = false;
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] == 0) {
                hasZero = true;
                break;
            }
        }
        if (hasZero) {
            temp[(*zeroRowsCount)++] = i;
        }
    }

    // Создание итогового массива с индексами строк
    int* zeroRows = (int*)malloc((*zeroRowsCount) * sizeof(int));
    if (zeroRows == NULL) {
        free(temp);
        *zeroRowsCount = 0;
        return NULL;
    }

    // Копирование данных из в. массива
    for (int i = 0; i < *zeroRowsCount; i++) {
        zeroRows[i] = temp[i];
    }

    free(temp);
    return zeroRows;
}

// Функция для удаления строк из матрицы
int** removeRows(int** matrix, int rows, int cols, int* zeroRows, int zeroRowsCount, int* newRows) {
    *newRows = rows - zeroRowsCount;

    // Если все строки удалены
    if (*newRows <= 0) {
        for (int i = 0; i < rows; i++) {
            free(matrix[i]);
        }
        free(matrix);
        return NULL;
    }

    // Создание новой матрицы без удаленных строк
    int** newMatrix = (int**)malloc((*newRows) * sizeof(int*));
    if (newMatrix == NULL) {
        *newRows = 0;
        return NULL;
    }

    int newRowIndex = 0;
    for (int i = 0; i < rows; i++) {
        bool skipRow = false;

        // Проверяем, нужно ли пропускать текущую строку
        for (int j = 0; j < zeroRowsCount; j++) {
            if (i == zeroRows[j]) {
                skipRow = true;
                break;
            }
        }

        if (!skipRow) {
            // Копируем строку
            newMatrix[newRowIndex] = (int*)malloc(cols * sizeof(int));
            for (int k = 0; k < cols; k++) {
                newMatrix[newRowIndex][k] = matrix[i][k];
            }
            newRowIndex++;
        }
    }

    // Освобождаем память старой матрицы
    for (int i = 0; i < rows; i++) {
        free(matrix[i]);
    }
    free(matrix);

    return newMatrix;
}

// Функция для вывода матрицы
void printMatrix(int** matrix, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
}

// Пункт 2: Работа с указателями
void processPointers() {
    cout << "\nПункт 2" << endl;

    int a, b;
    cout << "Введите значение переменной a: ";
    cin >> a;
    cout << "Введите значение переменной b: ";
    cin >> b;

    cout << "\nИсходные значения:" << endl;
    cout << "a = " << a << ", b = " << b << endl;

    // Создание указателей с помощью new
    int* pa = new int(a);
    int* pb = new int(b);

    cout << "Созданы указатели:" << endl;
    cout << "*pa = " << *pa << ", *pb = " << *pb << endl;

    // Увеличение значения a в 2 раза через указатель
    *pa *= 2;
    a = *pa; // Обновляем исходную переменную
    cout << "\nПосле увеличения a в 2 раза:" << endl;
    cout << "a = " << a << ", *pa = " << *pa << endl;

    // Обмен значений через указатели
    int temp = *pa;
    *pa = *pb;
    *pb = temp;

    // Обновляем исходные переменные
    a = *pa;
    b = *pb;

    cout << "\nПосле обмена значений:" << endl;
    cout << "a = " << a << ", b = " << b << endl;
    cout << "*pa = " << *pa << ", *pb = " << *pb << endl;

    // Освобождение памяти
    delete pa;
    delete pb;

    cout << "Память освобождена" << endl;
}

int main() {
    setlocale(LC_ALL, "Russian");

    int choice;
    cout << "Выберите пункт для выполнения (1 или 2): ";
    cin >> choice;

    if (choice == 1) {
        // Пункт 1: Работа с матрицами

        // Создание матрицы 2x2
        int** matrix = (int**)malloc(2 * sizeof(int*));
        for (int i = 0; i < 2; i++) {
            matrix[i] = (int*)malloc(2 * sizeof(int));
        }

        // Ввод данных с проверкой на отрицательные значения для A и B
        cout << "Введите элементы матрицы 2x2:" << endl;

        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                cout << "Элемент [" << i << "][" << j << "]: ";
                cin >> matrix[i][j];

                // Проверка для A (matrix[0][0]) и B (matrix[0][1])
                if ((i == 0 && j == 0 && matrix[i][j] < 0) ||
                    (i == 0 && j == 1 && matrix[i][j] < 0)) {
                    cout << "Ошибка, A и B не могут быть отрицательными. Повторите ввод." << endl;
                    j--; // Повторяем ввод для этого элемента
                }
            }
        }

        // Извлечение параметров
        int A = matrix[0][0];
        int B = matrix[0][1];
        int C = matrix[1][0];
        int D = matrix[1][1];

        cout << "\nИсходная матрица:" << endl;
        printMatrix(matrix, 2, 2);
        cout << "A = " << A << ", B = " << B << ", C = " << C << ", D = " << D << endl;

        // Создание матрицы
        int newRows = 2 + A;
        int newCols = 2 + B;

        int** extendedMatrix = (int**)malloc(newRows * sizeof(int*));
        for (int i = 0; i < newRows; i++) {
            extendedMatrix[i] = (int*)malloc(newCols * sizeof(int));
        }

        // Заполнение матрицы по формуле i*C + j*D
        for (int i = 0; i < newRows; i++) {
            for (int j = 0; j < newCols; j++) {
                extendedMatrix[i][j] = i * C + j * D;
            }
        }

        cout << "\nРасширенная матрица " << newRows << "x" << newCols << ":" << endl;
        printMatrix(extendedMatrix, newRows, newCols);

        // Поиск строк с нулевыми элементами
        int zeroRowsCount;
        int* zeroRows = findZeroRows(extendedMatrix, newRows, newCols, &zeroRowsCount);

        cout << "\nНайдено строк с нулевыми элементами: " << zeroRowsCount << endl;
        if (zeroRowsCount > 0) {
            cout << "Индексы строк с нулями: ";
            for (int i = 0; i < zeroRowsCount; i++) {
                cout << zeroRows[i] << " ";
            }
            cout << endl;
        }

        // Удаление строк с нулевыми элементами
        int finalRows;
        int** finalMatrix = removeRows(extendedMatrix, newRows, newCols, zeroRows, zeroRowsCount, &finalRows);

        // Результат
        if (finalMatrix != NULL && finalRows > 0) {
            cout << "\nФинальная матрица после удаления строк с нулями:" << endl;
            printMatrix(finalMatrix, finalRows, newCols);

            // Освобождение памяти для финальной матрицы
            for (int i = 0; i < finalRows; i++) {
                free(finalMatrix[i]);
            }
            free(finalMatrix);
        }
        else {
            cout << "\nСтроки удалены" << endl;
        }

        // Освобождение памяти
        if (zeroRows != NULL) {
            free(zeroRows);
        }

        // Освобождение памяти исходной матрицы
        for (int i = 0; i < 2; i++) {
            free(matrix[i]);
        }
        free(matrix);

    }
    else if (choice == 2) {
        // Пункт 2: Работа с указателями
        processPointers();
    }
    else {
        cout << "Ошибка. Выберите 1 или 2." << endl;
        return 1;
    }

    return 0;
}
